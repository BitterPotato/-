// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//uint groupSize = 15;
//uint groupNum = 4;
//float neighbor_allowed_dist = 50.0;
//float dtime = 0.4;

//float sepe_weight = 1.0;
//float cohe_weight = 1.0;
//float align_weight = 1.0;
//float change_weight = 1.0;
//float max_velocity = 10;

//cbuffer VS_CONSTANT_BUFFER : register(b0)
//{
//    uint groupSize;
//    uint groupNum;
//    float neighbor_allowed_dist;
//    float dtime;

//    float sepe_weight;
//    float cohe_weight;
//    float align_weight;
//    float change_weight;
//    float max_velocity;
//};

//VS_CONSTANT_BUFFER cb;
//cb.groupSize = 

//#define groupSize  15
//#define groupNum  4
//#define  neighbor_allowed_dist  50.0
//#define  dtime 0.4
//#define  sepe_weight 1.0
//#define  cohe_weight 1.0
//#define  align_weight  1.0
//#define  change_weight  1.0
//#define  max_velocity  10

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct Fish {
	float3 position;
	float3 velocity;
    float4 color;
};
RWStructuredBuffer<Fish> inputFishes;
RWStructuredBuffer<Fish> outputFishes;
// TODO: why cannot just use array
shared RWStructuredBuffer<Fish> tempFishes;

bool isNeighbor(float3 my_position, float3 other_position) {
	float3 distance = my_position - other_position;
	if(dot(distance, distance) < 20.0)
		return true;
	return false;
}
float3 seperation(float3 my_position, float3 other_position) {
	float3 distance = my_position - other_position;
	return distance;
}
// the dimensions of the thread groups being spawned
[numthreads(4,1,1)]
void CSMain (uint3 global_id : SV_DispatchThreadID, uint3 group_index : SV_GroupID
, uint3 local_id : SV_GroupThreadID)
{
	// TODO: insert actual code here!
 //   Fish now = inputFishes[global_id.x];
 //   Fish future;

 //   float3 my_position = now.position;
 //   float3 my_velocity = now.velocity;

 //   float3 center = my_position;
 //   float3 velo_aver = my_velocity;
 //   float3 accelleration;
 //   uint3 neighberCount = 0;

 //   for (uint i = 0; i < 4; i++)
 //   {
 //       Fish other = inputFishes[groupSize * i + local_id.x];
 //       tempFishes[local_id.x] = other;
 //       GroupMemoryBarrierWithGroupSync();

 //       for (uint j = 0; j < 15; j++)
 //       {
 //           other = tempFishes[j];
	//		// not self
 //           if (i * groupSize + j != global_id.x && isNeighbor(my_position, other.position))
 //           {
 //               neighberCount++;

 //               center += other.position;
 //               velo_aver += other.velocity;
 //               accelleration += seperation(my_position, other.position) * sepe_weight;
 //           }
 //       }
 //       GroupMemoryBarrierWithGroupSync();
 //   }

 //   center /= neighberCount;
 //   velo_aver /= neighberCount;

 //   future.position = now.position + now.velocity * dtime;

	//// Cohesion
 //   accelleration += (center - my_position) * cohe_weight;
	//// Alignment
 //   accelleration += (velo_aver - my_velocity) * align_weight;
 //   future.velocity = now.velocity + accelleration * dtime;

 //   if (length(future.velocity) > max_velocity)
 //       future.velocity = normalize(future.velocity) * max_velocity;
 //   future.velocity = lerp(my_velocity, future.velocity, change_weight);

 //   future.color = now.color;
 //   outputFishes[global_id.x] = future;

    //Fish now = inputFishes[global_id.x];
    //Fish future;
    //future.color = now.color;
    //future.position = now.position + float3(0.01, 0.0, 0.0);
    //future.velocity = now.velocity;
    //outputFishes[global_id.x] = future;


    Fish now = inputFishes[global_id.x];
    Fish future;

    float3 my_position = now.position;
    float3 my_velocity = now.velocity;

    float3 center = my_position;
    float3 velo_aver = my_velocity;
    float3 accelleration;
    uint3 neighberCount = 1;

    for (uint i = 0; i < 4; i++)
    {
        Fish other = inputFishes[15 * i + local_id.x];
        tempFishes[local_id.x] = other;
        GroupMemoryBarrierWithGroupSync();

        for (uint j = 0; j < 15; j++)
        {
            other = tempFishes[j];
			// not self
            if (i * 15 + j != global_id.x && isNeighbor(my_position, other.position))
            {
                neighberCount++;

                center += other.position;
                velo_aver += other.velocity;
                accelleration += seperation(my_position, other.position) * 0.1;
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }

    center /= neighberCount;
    velo_aver /= neighberCount;

    future.position = now.position + now.velocity * 0.04;

	// Cohesion
    accelleration += (center - my_position) * 5.0;
	// Alignment
    accelleration += (velo_aver - my_velocity) * 1.0;
    future.velocity = now.velocity + accelleration * 0.4;

    if (length(future.velocity) > 5)
        future.velocity = normalize(future.velocity) * 5;
    future.velocity = lerp(my_velocity, future.velocity, 1.0);

    future.color = now.color;
    outputFishes[global_id.x] = future;
}
