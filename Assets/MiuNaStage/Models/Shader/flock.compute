// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define GROUP_SIZE 15

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct Fish {
	float3 position;
	float3 velocity;
    float4 color;
};
RWStructuredBuffer<Fish> inputFishes;
RWStructuredBuffer<Fish> outputFishes;
// TODO: why cannot just use array
shared RWStructuredBuffer<Fish> tempFishes;

struct FlockParameter
{
    float neighbor_allowed_dist;
    float dtime;
    float sepe_weight;
    float cohe_weight;
    float align_weight;
    float mix_weight;
    float max_velocity;
};

RWStructuredBuffer<FlockParameter> argsBuffer;

bool isNeighbor(float3 my_position, float3 other_position) {
	float3 distance = my_position - other_position;
    if (dot(distance, distance) < argsBuffer[0].neighbor_allowed_dist)
		return true;
	return false;
}
float3 seperation(float3 my_position, float3 other_position)
{
    float3 distance = my_position - other_position;
    if (dot(distance, distance) > argsBuffer[0].neighbor_allowed_dist)
        return float3(0.0, 0.0, 0.0);
    return distance;
}
//float3 seperation(float3 my_position, float3 other_position) {
//	float3 distance = my_position - other_position;
//	return distance;
//}
// the dimensions of the thread groups being spawned
[numthreads(4,1,1)]
void CSMain (uint3 global_id : SV_DispatchThreadID, uint3 group_index : SV_GroupID
, uint3 local_id : SV_GroupThreadID)
{
	 //TODO: insert actual code here!
    Fish now = inputFishes[global_id.x];
    Fish future;

    float3 my_position = now.position;
    float3 my_velocity = now.velocity;

    float3 center = my_position;
    float3 velo_aver = my_velocity;
    float3 accelleration;
    uint3 neighberCount = 1;

    for (uint i = 0; i < 4; i++)
    {
        Fish other = inputFishes[GROUP_SIZE * i + local_id.x];
        tempFishes[local_id.x] = other;
        //GroupMemoryBarrierWithGroupSync();
        AllMemoryBarrierWithGroupSync();

        for (uint j = 0; j < 15; j++)
        {
            other = tempFishes[j];
			// not self
            if (i * GROUP_SIZE + j != global_id.x)
            {
                neighberCount++;

                center += other.position;
                velo_aver += other.velocity;
                accelleration += seperation(my_position, other.position) * argsBuffer[0].sepe_weight;
            }
        }
        //GroupMemoryBarrierWithGroupSync();
        AllMemoryBarrierWithGroupSync();
    }

    center /= neighberCount;
    velo_aver /= neighberCount;

    future.position = now.position + now.velocity * argsBuffer[0].dtime;

	// Cohesion
    accelleration += (center - my_position) * argsBuffer[0].cohe_weight;
	// Alignment
    accelleration += (velo_aver - my_velocity) * argsBuffer[0].align_weight;
    future.velocity = now.velocity + accelleration * argsBuffer[0].dtime;

    if (length(future.velocity) > argsBuffer[0].max_velocity)
        future.velocity = normalize(future.velocity) * argsBuffer[0].max_velocity;
    future.velocity = lerp(my_velocity, future.velocity, argsBuffer[0].mix_weight);

    future.color = now.color;
    future.color.x = 1.0 - neighberCount / 100.0;
    outputFishes[global_id.x] = future;

    //Fish now = inputFishes[global_id.x];
    //Fish future;
    //future.color = now.color;
    ////future.position = now.position;
    //future.position = now.position + argsBuffer[0].align_weight * float3(0.02, 0.0, 0.0);
    //future.velocity = now.velocity;
    //outputFishes[global_id.x] = future;
}
